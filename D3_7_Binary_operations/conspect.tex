\documentclass[12pt]{article}
%\bibliographystyle{unsrt}
\bibliographystyle{gost780u}
\usepackage{cite}
\usepackage[nottoc]{tocbibind}
\usepackage{a4wide}
%\usepackage[utf8]{inputenc}
\usepackage[cp1251]{inputenc}
\usepackage[T2A]{fontenc}
\usefont{T2A}{qcr}{m}{n}
\usepackage{graphics,graphicx}
\usepackage{subfig}
\usepackage{amssymb,amsfonts,amsthm,amsmath,mathtext,cite,enumerate,float}
\usepackage[english,russian]{babel}
%\input{ix-utf8enc.dfu}
\usepackage{tikz}
\usepackage{slashbox}
\usepackage{epsfig}
\usepackage{subfig}
\usepackage{multicol}
\usepackage{epstopdf} 
\usepackage{hyperref}
\newcommand*{\vect}[1]{\overrightarrow{#1}}
\newcommand*{\egref}[1]{(\ref{#1})}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,max}
\def\R{\mathbb{R}}
\def\N{\mathbb{N}}
\def\A{\mathbb{A}}
\def\B{\mathbb{B}}
\def\Z{\mathbb{Z}}
\graphicspath{ {eps/} }

\newtheorem{Def}{Определение}
\newtheorem{Definition}[Def]{Определение}
\setcounter{Def}{0}%
\usepackage{tabularx}

\textheight=24cm  % высота текста
\textwidth=16cm % ширина текста
\oddsidemargin=0pt % отступ от левого края
\topmargin=-1.5cm % отступ от верхнего края
\parindent=24pt % абзацный отступ
\parskip=0pt % интервал между абзацами
\tolerance=2000 % "терпимость" к жидким строкам
\flushbottom % выравнивание высоты страниц
%\graphicspath{{data/}}
%\graphicspath{{data/further_research/final_pic/}}
\renewcommand{\baselinestretch}{1.3}
\fontsize{13}{15.6}\selectfont

%\bibliographystyle{unsrt}
\linespread{1.5}

%%Листинг:
\usepackage{xcolor}
\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings} %% собственно, это и есть пакет listings
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}} %% это сделает текст заголовка белым
%% код ниже нарисует серую рамочку вокруг заголовка кода.
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

\newcommand{\booleantable}[5]{\begin{tabular}{c|c c}
#1 & 0 & 1 \\
\hline
0 & #2 & #3 \\
1 & #4 & #5 \\
\end{tabular}}

\newcommand{\booleantableunar}[3]{\begin{tabular}{c|c c}
#1 & 0 & 1 \\
\hline
  & #2 & #3 \\
\end{tabular}}



\begin{document}
%Листинг:
\lstset{ %
language=Pascal,                 % выбор языка для подсветки (здесь это С++)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\small,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=10pt,                % как далеко отстоят номера строк от подсвечиваемого кода
backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)},   % если нужно добавить комментарии в коде
basicstyle=\small\ttfamily,
keywordstyle=\bfseries\color{green!40!black},
commentstyle=\itshape\color{purple!40!black},
identifierstyle=\color{blue},
stringstyle=\color{orange},
}
\renewcommand{\lstlistingname}{Решение}

\begin{center}
\begin{Large}
22.01.17. Группа D3. Занятие 7. \\ Бинарные операции.\\
\end{Large}
Подготовил \href{https://vk.com/ivansol42}{Соломатин Иван Андреевич}. \\
ivan.solomatin@phystech.edu; solomatin@informatics.ru
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Побитовые логические операции}
С уроков дискретной математики вам должны быть известны булевы функции, приведённые на таблице \ref{tab:bool}. У этих булевых функций в большинстве языков программирования есть соответствующие бинарные операции, которые так же приведены на таблице \ref{tab:bool}.

\begin{table}[H]
\begin{tabularx}{\textwidth}{|X|c|c|c|}
\hline
Название функции & Pascal & C++ & Таблица истинности \\
\hline
И (Дизъюнкция) & and & \& & \booleantable\&0001 \\
\hline
ИЛИ (Коньюнкция) & or & | & \booleantable|0111 \\
\hline
Не (Отрицание) & not & $\sim$ & \booleantableunar!10 \\
\hline
Исключающее или (Xor) & xor & \Huge{\^{}} & \booleantable{\^{}}0110 \\
\hline
\end{tabularx}
\caption{Булевы функции}
\label{tab:bool}
\end{table}
%\begin{tabular}{|c|c|c|c|}

В дискретной математике эти операции применяются только булевым значениям, однако в языках программирования их можно применять и к целым числам. Например,
\begin{equation}
\label{example}
\text{Pascal}: \;\;\;\; 14 \; \textbf{and} \; 5 = 4
\end{equation}
Почему так происходит? Всё очень просто. Как известно, целые числа хранятся в памяти компьютера в двоичном коде. Вышеописанные булевы функции просто применяются к каждому биту двух чисел и результат записывается в соответствующий бит результата. То есть, в примере \ref{example} происходит следующее:
\begin{equation}
\begin{aligned}
14 \; &=& 1110_2 \\
5  \; &=& 0101_2  \\
14 \; \textbf{and} \; 5 = 4 \; &=& 0100_2
\end{aligned}
\end{equation}
%\end{tabular}
Логическое И, применённое к каждому биту даёт единицу только на третьем бите, т.к. они равны 1 у обоих чисел.\\

\textbf{Упражнение.} Чему равны: 
\begin{itemize}
\item $14 \; \textbf{or} \; 5,$
\item $14 \; \textbf{and} \; \textbf{not} \; 5,$
\item $16 \; \textbf{or} \; 15$ ?
\end{itemize}
\section{Битовый сдвиг}
Есть ещё два важных битовых оператора. Битовый сдвиг влево и битовый сдвиг вправо. Этим операторы не строятся на основе булевых функций над битами, а просто сдвигают биты числа вправо или влево, заполняя лишние биты нулями.

\begin{table}[H]
\begin{tabularx}{\textwidth}{|X|c|c|}
\hline
Название функции & Pascal & C++ \\
\hline
Бинарный сдвиг x влево на k & x \textbf{shl} k & x $<<$ k \\
\hline
Бинарный сдвиг x вправо на k & x \textbf{shr} k & x $>>$ k \\
\hline
\end{tabularx}
\caption{Операторы сдвига}
\label{tab:shift}
\end{table}
Стоит заметить, что оператор сдвига не изменяет саму переменную к которой применяется, а возвращает результат как обычная функция. Т.е. такой код:
\begin{lstlisting}[label=some-code]
var
	x, y: integer;
begin
	x := 1;
	x shl 2;
	y := x shl 2;
	writeln(x, ' ', y);
end.
\end{lstlisting}
Выведет на экран <<1 4>>, так как в 5 строке значение вычисляется, но никуда не сохраняется, и вообще говоря, строка 5 не имеет смысла.

Если вспомнить как записывается число в двоичном коде, то для оператора сдвига можно получить математическое выражение.
Если в двоичном коде число имеет вид:
\begin{equation}
x = a_na_{n-1}\cdots a_1a_0,
\end{equation}
где $a_n, \cdots, a_0$ - цифры (0 либо 1), то тогда:
\begin{equation}
x = a_n * 2^n + a_{n-1} * 2^{n-1} + \cdots + a_1 * 2 + a_0.
\end{equation}
Посмотрим, что произойдёт при сдвиге влево на $k$ битов, если первые k битов были равны 0:
$$
x = \underbrace{00\cdots00}_{k}a_{n-k}a_{n-k-1}\cdots a_1a_0
$$
\begin{equation}
x = a_{n-k} * 2^{n-k} + a_{n-k-1} * 2^{n-k-1} + \cdots + a_1 * 2 + a_0
\end{equation}
$$
x \; \textbf{shl} \; k = a_{n-k}a_{n-k-1}\cdots a_1a_0\underbrace{00\cdots00}_{k} \\
$$
$$
x \; \textbf{shl} \; k = a_{n-k} * 2^{n} + a_{n-k-1} * 2^{n-1} + \cdots + a_{1} * 2^{k+1} + a_0 * 2^k.
$$
Заметим, что
\begin{equation}
x \; \textbf{shl} \; k = x * 2^k.
\end{equation}
Таким образом, если при умножении числа $x$ на $2^k$, число не переполнится (значение вмещается в тип), то это умножение можно выполнить с помощью бинарного сдвига влево на $k$ бит.
Для сдвига вправно аналогично можно получить формулу:
\begin{equation}
x \; \textbf{shr} \; k = x \; \textbf{div} \; 2^k.
\end{equation}

\end{document}