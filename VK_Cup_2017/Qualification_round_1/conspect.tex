\documentclass[12pt]{article}
%\bibliographystyle{unsrt}
\bibliographystyle{gost780u}
\usepackage{cite}
\usepackage[nottoc]{tocbibind}
\usepackage{a4wide}
%\usepackage[utf8]{inputenc}
\usepackage[cp1251]{inputenc}
\usepackage[T2A]{fontenc}
\usefont{T2A}{qcr}{m}{n}
\usepackage{graphics,graphicx}
\usepackage{subfig}
\usepackage{amssymb,amsfonts,amsthm,amsmath,mathtext,cite,enumerate,float}
\usepackage[english,russian]{babel}
%\input{ix-utf8enc.dfu}
\usepackage{tikz}
\usepackage{slashbox}
\usepackage{epsfig}
\usepackage{subfig}
\usepackage{multicol}
\usepackage{epstopdf} 
\usepackage{hyperref}
\newcommand*{\vect}[1]{\overrightarrow{#1}}
\newcommand*{\egref}[1]{(\ref{#1})}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,max}
\def\R{\mathbb{R}}
\def\N{\mathbb{N}}
\def\A{\mathbb{A}}
\def\B{\mathbb{B}}
\def\Z{\mathbb{Z}}
\graphicspath{ {eps/} }

\newtheorem{Def}{Определение}
\newtheorem{Definition}[Def]{Определение}
\setcounter{Def}{0}%
\usepackage{tabularx}

\textheight=24cm  % высота текста
\textwidth=16cm % ширина текста
\oddsidemargin=0pt % отступ от левого края
\topmargin=-1.5cm % отступ от верхнего края
\parindent=24pt % абзацный отступ
\parskip=0pt % интервал между абзацами
\tolerance=2000 % "терпимость" к жидким строкам
\flushbottom % выравнивание высоты страниц
%\graphicspath{{data/}}
%\graphicspath{{data/further_research/final_pic/}}
\renewcommand{\baselinestretch}{1.3}
\fontsize{13}{15.6}\selectfont

%\bibliographystyle{unsrt}
\linespread{1.5}

%%Листинг:
\usepackage{xcolor}
\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings} %% собственно, это и есть пакет listings
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}} %% это сделает текст заголовка белым
%% код ниже нарисует серую рамочку вокруг заголовка кода.
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%Листинг:
\lstset{ %
language=C++,                 % выбор языка для подсветки (здесь это С++)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\small,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=10pt,                % как далеко отстоят номера строк от подсвечиваемого кода
backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)},   % если нужно добавить комментарии в коде
basicstyle=\small\ttfamily,
keywordstyle=\bfseries\color{green!40!black},
commentstyle=\itshape\color{purple!40!black},
identifierstyle=\color{blue},
stringstyle=\color{orange},
}
\renewcommand{\lstlistingname}{Решение}

\begin{center}
\begin{Large}
13.03.17. Разбор задач с VKcup2017 Qualification round 1. \\
\end{Large}
Подготовил \href{https://vk.com/ivansol42}{Соломатин Иван Андреевич}. \\
ivan.solomatin@phystech.edu; solomatin@informatics.ru
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Задача А.}
Смысл задачи прост - т.к. Игорь вступает в группы, год которых отличается не более чем на $х$, можно легко найти год поступления Игоря как медиану введённого массива. Это удобно сделать с помощью встроенной функции sort из библиотеки algorithm. Медиана массива из N элементов находится на месте $\cfrac{N}{2}$. Ниже приведён код на С++, решающий данную задачу.
\lstinputlisting{A.cpp}

\section{Задача B.}
Прежде всего, заметим, что для того чтобы было возможно сообщить новость всем студентам, необходимо выполнение двух условий:
\begin{equation}
\label{req1}
\sum\limits_{i \in [1; N]} a_i \geq N - 1,
\end{equation}
\begin{equation}
\label{req2}
a_1 > 0.
\end{equation}
Условия следуют из следующих рассуждений. Для того, чтобы сообщить новость всем, нужно, вообще говоря, построить ориентированное дерево на всех вершинах с корнем в вершине $1$. В дереве из $N$ вершин, как известно, ровно $N-1$ рёбер $\Rightarrow$ (\ref{req1}). Из корня дерева должно выходить хотя бы одно ребро $\Rightarrow$ (\ref{req2}).

Задача решается с помощью жадного алгоритма. Отсортируем студентов (всех, кроме Поликарпа, имеющего номер 1) в порядке убывания $a_i$. Будем идти по массиву в порядке убывания $a_i$ и для каждого студента $i$ "сообщать" новость $a_i$ ближайшим справа студентам, которые ещё не получили новость.

Докажем правильность такой процедуры:
\begin{enumerate}
\item Назовём количество студентов, не знающих новость $K$. Изначально никто кроме Поликарпа не знает новость, т.е. количество студентов не знающих новость: $K = N-1$.
\item На каждом шаге мы сообщаем новость студенту, который до этого её не знал, то есть уменьшаем $K$ на 1.
\item По требованию \ref{req1}: $\sum\limits_{i \in [1; N]} a_i \geq N - 1$, таким образом, процедура выполнится хотя бы $N - 1$ раз. Из предыдущих пунктов следует, что при выполнении процедуры $N-1$ раз, $K$ станет равно $0$, то есть все студенты будут знать новость, что соответствует условию задачи.
\end{enumerate}
Ниже приведён код, решающий данную задачу.
\lstinputlisting{B.cpp}

\section{Задача C.}
Для начала сформулируем условие существования ответа. Прежде всего, нужно иметь возможность сделать хотя бы один шаг из начального положения. Кроме того, несложно доказать, что для существования цикла необходимо, чтобы его длина $K$ была чётной. Действительно, заметим, что при совершении любого шага сумма координат текущего положения $(i + j)$ изменяется ровно на $1$. Так как после совершения цикла, мы должнны попасть в исходное положение $(i_0, j_0)$, его чётность должна сохраниться, значит количество изменений суммы координат должно быть чётно, значит, количество шагов должно быть чётно.

Заметим, что для того чтобы получить лексикографически минимальный путь, на каждом шаге нам выгодно выбирать лексикографически минимальный из возможных ходов.
Первое приходящее в голову решение - разбить путь на два подпути $p_1, p_2$ длины $|p_1| = |p_2| = \cfrac{K}{2}$, при этом $p1$ минимизировать лексикографически (на каждом шаге совершать лексикографически минимальное действие), а  подпуть $p_2$ будет представлять из себя инвертированный подпуть $p_1$ (для того, чтобы вернуться в исходную позицию). Однако, такой подход не всегда верен. Пример теста, на котором такое решение даёт неверный ответ:
\begin{lstlisting}[label=Test1]
4 4 16
..X.
.**.
..*.
*...
\end{lstlisting}
На таком тесте вышеописанное решение даёт ответ:
\begin{center}
LLDDRDRLRLULUURR
\end{center}
Что, вообще говоря, неверно, так как существует лексикографическим меньший цикл:
\begin{center}
LLDDRDRLRLRRUUUL
\end{center}

Проблема в том, что на 11-м шаге в вышеописанном решении уже начался подпуть 2 и поэтому, совершается шаг $U$, хотя шаг $R$ лексикографическим меньше $U$ и так же допустим.

Модифицируем идею. Будем разбивать путь не на два подпути $p_1, p_2$ равной длины, а на подпуть $p_1$ длины $|p_1| = l_1$ и подпуть $p_2$ длины $|p_2| = l_2$: $l_1+l_2 = K$. Причём $p_1$ будем минимизировать лексикографически, а $p_2$ - по длине. Идея этого решения состоит в том, что мы хотим идти лексикографически минимальным путём как можно дольше.

Реализуем эту идею. Для начала посчитаем длину минимального пути $d(i, j)$ из начальной позиции $(i_0, j_0)$ в позицию $(i, j)$. Это удобно сделать с помощью BFS.
Далее, идём лексикографически минимальными шагами пока не обнаружим, что минимальное расстояние до начальной вершины равно оставшейся длине пути.

Более подробно. Пусть мы сделали $k$ шагов и оказались в вершине $v = (i_v, j_v)$ и при этом $d(i_v, j_v) = K - k$. Это значит, что если мы сделаем шаг в $(i', j'): d(i', j') \geq d(i_v, j_v)$, то уже не успеем вернуться в начальное положение за оставшееся число шагов. Поэтому, нужно совершать шаг в вершину  $(i', j'): d(i', j') = d(i_v, j_v) - 1$, причём из всех таких - лексикографически минимальный.
Более подробно. Пусть мы сделали $k$ шагов и оказались в вершине $v = (i_v, j_v)$ и при этом $d(i_v, j_v) = K - k$. Это значит, что если мы сделаем шаг в $(i', j'): d(i', j') \geq d(i_v, j_v)$, то уже не успеем вернуться в начальное положение за оставшееся число шагов. Поэтому, нужно совершать шаг в вершину  $(i', j'): d(i', j') = d(i_v, j_v) - 1$, причём из всех таких - лексикографически минимальный.

Итак, мы получаем путь $p = p_1 + p_2$, причём $p_1$ - лексикографически минимальный подпуть $(i_0, j_0) \to (i_v, j_v)$, а $p_2$ - кратчайший путь $(i_v, j_v) \to (i_0, j_0)$, причём из всех кратчайших путей - лексикографически минимальный. Несложно доказать, что такой цикл будет лексикографически минимальным.

Ниже приведён код, решающий данную задачу.
\lstinputlisting{C.cpp}

\section{Задача D.}
Первое приходящее в голову решение~--- перебрать все пары чисел, проверить их на <<$k$-интересность>>, посчитать количество $k-$интересных пар чисел. Такое решение имеет сложность $O(N^2)$ и, к сожалению, не проходит по TL при ограничениях $2 \leq n leq 10^5$. Однако, такое решение достаточно просто пишется и может быть использовано, например, для стресс тестирования асимптотически верного решения.

\lstinputlisting{D_N2.cpp}

Нужно более быстрое решение. Заметим, что ограничения на количество бит и на величину $a_i$ малы: $0 \leq k \leq 14, 0 \leq a_i \leq 10^4$. Это наблюдение можно использовать для ускорения алгоритма.

Заметим, что если мы рассмотрим некоторый набор $X$, состоящий из $k$ бит, то для каждого конкретного числа $a$ можно однозначно определить число $b$, такое что $a$ и $b$~--- $k-$интересны и отличаются в битах из набора $X$. Такое число $b$ легко найти, поменяв в числе $a$ биты, стоящие на местах из набора $X$.

Пусть такой набор $X$ задаётся битовой маской $mask$ (если $i$-й бит числа $mask$ равен $1$, будем считать, что $i \ in X$, если $0$, будем считать, что $i ]not \in X$). Нас интересуют такие наборы, в которых ровно $K$ бит, т.е. маски, в которых $K$ единичек. Количество таких наборов (масок) можно найти из комбинаторых соображений:
$$N_{masks} = {\sf C}_{14}^{k}$$ 
В худшем случае это:
$$N_{masks} = {\sf C}_{14}^{7} = 3432,$$ 
что совсем немного.

Далее, зная маску мы можем по каждому числу $a$ можно за O(1) узнать число $b(a, mask) = a \; \textbf{xor} \; mask$, которое $k-$интересно с $a$ по маске $mask$. То есть, фиксируя маску $mask$ и число $a$ мы получаем $k-$интересную пару:
$$a; a \; \textbf{xor} \; mask$$

Удобно при считывании вычислить массив cnt, в $i$-й ячейке которого будет храниться, сколько раз число $i$ встретилось во входном массиве. Тогда ответ на задачу это сумма cnt[a]*cnt[a \; \textbf{xor} \; mask]/2. Важно не забыть разделить сумму пополам, чтобы учесть требование условия задачи $i < j$.
$$ans = \cfrac{\sum\limits_{mask} \sum_{a \in [a_{min}; a_{max}]} cnt[a]*cnt[a \; \textbf{xor} \; mask]}{2},$$
где первая сумма берётся по маскам, содержащим ровно $k$ единичных бит, а вторая по всем числам $a_{min} \leq a \leq a_{max}$, где $a_{min}$ и $a_{max}$ - минимальное и максимальное число во входном массиве.

У описанного решения есть единственный частный случай: $K = 0$. В этом случае ответ - количество пар одинковых чисел во входном массиве. Из комбинаторных сообржений, количество таких пар:
$$ans = \cfrac{\sum_{a \in [a_{min}; a_{max}]} cnt[a]*(cnt[a] - 1)}{2},$$

Сложность такого решения: $O((a_{max} - a_{min})*{\sf C}_{14}^k)$, что с большим запасом укладывается в TL.
Ниже приведён код, решающий данную задачу.

\lstinputlisting{D.cpp}
%\begin{lstlisting}[label=Problem D (Long solution)]
%int main()
%{
%	return 0
%}
%\end{lstlisting}

\end{document}
