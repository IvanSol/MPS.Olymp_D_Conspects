\documentclass[12pt]{article}
%\bibliographystyle{unsrt}
\bibliographystyle{gost780u}
\usepackage{cite}
\usepackage[nottoc]{tocbibind}
\usepackage{a4wide}
%\usepackage[utf8]{inputenc}
\usepackage[cp1251]{inputenc}
\usepackage[T2A]{fontenc}
\usefont{T2A}{qcr}{m}{n}
\usepackage{graphics,graphicx}
\usepackage{subfig}
\usepackage{amssymb,amsfonts,amsthm,amsmath,mathtext,cite,enumerate,float}
\usepackage[english,russian]{babel}
%\input{ix-utf8enc.dfu}
\usepackage{tikz}
\usepackage{slashbox}
\usepackage{epsfig}
\usepackage{subfig}
\usepackage{multicol}
\usepackage{epstopdf} 
\usepackage{hyperref}
\newcommand*{\vect}[1]{\overrightarrow{#1}}
\newcommand*{\egref}[1]{(\ref{#1})}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,max}
\def\R{\mathbb{R}}
\def\N{\mathbb{N}}
\def\A{\mathbb{A}}
\def\B{\mathbb{B}}
\def\Z{\mathbb{Z}}
\graphicspath{ {eps/} }

\newtheorem{Def}{Определение}
\newtheorem{Definition}[Def]{Определение}
\setcounter{Def}{0}%
\usepackage{tabularx}

\textheight=24cm  % высота текста
\textwidth=16cm % ширина текста
\oddsidemargin=0pt % отступ от левого края
\topmargin=-1.5cm % отступ от верхнего края
\parindent=24pt % абзацный отступ
\parskip=0pt % интервал между абзацами
\tolerance=2000 % "терпимость" к жидким строкам
\flushbottom % выравнивание высоты страниц
%\graphicspath{{data/}}
%\graphicspath{{data/further_research/final_pic/}}
\renewcommand{\baselinestretch}{1.3}
\fontsize{13}{15.6}\selectfont

%\bibliographystyle{unsrt}
\linespread{1.5}

%%Листинг:
\usepackage{xcolor}
\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings} %% собственно, это и есть пакет listings
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}} %% это сделает текст заголовка белым
%% код ниже нарисует серую рамочку вокруг заголовка кода.
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%Листинг:
\lstset{ %
language=C++,                 % выбор языка для подсветки (здесь это С++)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\small,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=10pt,                % как далеко отстоят номера строк от подсвечиваемого кода
backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)},   % если нужно добавить комментарии в коде
basicstyle=\small\ttfamily,
keywordstyle=\bfseries\color{green!40!black},
commentstyle=\itshape\color{purple!40!black},
identifierstyle=\color{blue},
stringstyle=\color{orange},
}
\renewcommand{\lstlistingname}{Решение}

\begin{center}
\begin{Large}
08.03.17. Разбор задач с VKcup2017 Qualification round 1. \\
\end{Large}
Подготовил \href{https://vk.com/ivansol42}{Соломатин Иван Андреевич}. \\
ivan.solomatin@phystech.edu; solomatin@informatics.ru
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Задача А.}
Смысл задачи прост - т.к. Игорь вступает в группы, год которых отличается не более чем на $х$, можно легко найти год поступления Игоря как медиану введённого массива. Это удобно сделать с помощью встроенной функции sort из библиотеки algorithm. Медиана массива из N элементов находится на месте $\cfrac{N}{2}$. Ниже приведён код на С++, решающий данную задачу.
\begin{lstlisting}[label=Problem A]
int main()
{
	return 0
}
\end{lstlisting}

\section{Задача B.}
Прежде всего, заметим, что для того чтобы сообщить новость всем студентам, необходимо выполнение двух условий:
\begin{equation}
\label{req1}
\sum\limits_i \in \[1; N\] a_i \geq N - 1,
\end{equation}
\begin{equation}
\label{req2}
a_1 > 0.
\end{equation}
Условия следуют из того, что для того, чтобы сообщить новость всем, нужно, вообще говоря, построить ориентированное дерево на всех вершинах с корнем в вершине $1$. В дереве из $N$ вершине, как известно, ровно $N-1$ рёбер $\Rightarrow$ (\ref{req1}). Из корня дерева должно выходить хотя бы одно ребро $\Rightarrow$ (\ref{req2}).

Задача решается с помощью жадного алгоритма. Отсортируем студентов (всех, кроме Поликарпа, имеющего номер 1) в порядке убывания $a_i$. Будем идти по массиву в порядке убывания $a_i$ и для каждого студента $i$ "сообщать" новость $a_i$ ближайшим справа студентам, которые ещё не получили новость.

Докажем правильность такой процедуры:
\begin{enumerate}
\item Назовём количество студентов, не знающих новость $K$. Изначально никто кроме Поликарпа не знает новость, т.е. количество студентов не знающих новость: $K = N-1$.
\item На каждом шаге мы сообщаем новость студенту, который до этого её не знал, то есть уменьшаем $K$ на 1.
\item По требованию \ref{req1}: $\sum\limits_i \in \[1; N\] a_i \geq N - 1$, таким образом, процедура выполнится хотя бы $N - 1$ раз. Из предыдущих пунктов следует, что при выполнении процедуры $N-1$ раз, $K$ станет равно $0$, то есть все студенты будут знать новость, что соответствует условию задачи.
\end{enumerate}
Ниже приведён код, решающий данную задачу.
\begin{lstlisting}[label=Problem B]
int main()
{
	return 0
}
\end{lstlisting}

\section{Задача C.}
Для начала сформулируем условия существования ответа. Прежде всего, нужно иметь возможность сделать хотя бы один шаг из начального положения. Кроме того, несложно доказать, что для существования цикла необходимо, чтобы его длина $K$ была чётной. Действительно, заметим, что при совершении любого шага сумма координат текущего положения $(i + j)$ изменяется ровно на $1$. Так как после совершения цикла, мы должнны попасть в исходное положение $(i_0, j_0)$, его чётность должна сохраниться, значит количество изменений суммы координат должно быть чётно, значит, количество шагов должно быть чётно.

Заметим, что для того чтобы получить лексикографически минимальный путь, на каждом шаге нам выгодно выбирать лексикографически минимальный из возможных ходов.
Первое приходящее в голову решение - разбить путь на два подпути длины $\cfrac{K}{2}$, первый из которых будет минимизироваться лексикографически (каждый шаг будет лексикографически минимальным из возможных), а второй подпуть будет представлять из себя инвертированный первый подпуть (для того, чтобы вернуться в исходную позицию). Однако, такой подход не всегда верен. Пример теста, на котором такое решение даёт неверный ответ:
\begin{lstlisting}[label=Test1]
4 4 16
..X.
.**.
..*.
*...
\end{lstlisting}
На таком тесте вышеописанное решение даёт ответ:
\begin{center}
LLDDRDRLRLULUURR
\end{center}
Что, вообще говоря, неверно, так как существует лексикографическим меньший цикл:
\begin{center}
LLDDRDRLRLRRUUUL
\end{center}

Проблема в том, что на 11-м шаге в вышеописанном решении уже начался подпуть 2 и поэтому, совершается шаг $U$, хотя, допустим так же лексикографически меньший шаг $R$.

Модифицируем идею. Будем разбивать путь не на два подпути $p_1, p_2$ равной длины, а на подпуть $p_1$ длины $|p_1| = l_1$ и подпуть $p_2$ длины $|p_2| = l_2$: $l_1+l_2 = K$. Причём $p_1$ будем минимизировать лексикографически, а $p_2$ - по длине. Идея этого решения состоит в том, что мы хотим идти лексикографически минимальным путём как можно дольше.

Реализуем эту идею. Для начала посчитаем длину минимального пути $d(i, j)$ из начальной позиции $(i_0, j_0)$ в позицию $(i, j)$. Это удобно сделать с помощью BFS.
Далее, идём лексикографически минимальными шагами пока не обнаружим, что минимальное расстояние до начальной вершины равно оставшейся длине пути.

Более подробно. Пусть мы сделали $k$ шагов и оказались в вершине $v = (i_v, j_v)$ и при этом $d(i_v, j_v) = K - k$. Это значит, что если мы сделаем шаг в $(i', j'): d(i', j') \geq d(i_v, j_v)$, то уже не успеем вернуться в начальное положение за оставшееся число шагов. Поэтому, нужно совершать шаг в вершину  $(i', j'): d(i', j') = d(i_v, j_v) - 1$, причём из всех таких - лексикографически минимальный.

Итак, мы получаем путь $p = p_1 + p_2$, причём $p_1$ - лексикографически минимальный подпуть $(i_0, j_0) \to (i_v, j_v)$, а $p_2$ - кратчайший путь $(i_v, j_v) \to (i_0, j_0)$, причём из всех кратчайших путей - лексикографически минимальный.
\begin{equation}

\end{equation}

\begin{lstlisting}[label=Problem C]
int main()
{
	return 0
}
\end{lstlisting}

\end{document}