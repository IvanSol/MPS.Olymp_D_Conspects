\documentclass[12pt]{article}
%\bibliographystyle{unsrt}
\bibliographystyle{gost780u}
\usepackage{cite}
\usepackage[nottoc]{tocbibind}
\usepackage{a4wide}
%\usepackage[utf8]{inputenc}
\usepackage[cp1251]{inputenc}
\usepackage[T2A]{fontenc}
\usefont{T2A}{qcr}{m}{n}
\usepackage{graphics,graphicx}
\usepackage{subfig}
\usepackage{amssymb,amsfonts,amsthm,amsmath,mathtext,cite,enumerate,float}
\usepackage[english,russian]{babel}
%\input{ix-utf8enc.dfu}
\usepackage{tikz}
\usepackage{slashbox}
\usepackage{epsfig}
\usepackage{subfig}
\usepackage{multicol}
\usepackage{epstopdf} 
\usepackage{hyperref}
\newcommand*{\vect}[1]{\overrightarrow{#1}}
\newcommand*{\egref}[1]{(\ref{#1})}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,max}
\def\R{\mathbb{R}}
\def\N{\mathbb{N}}
\def\A{\mathbb{A}}
\def\B{\mathbb{B}}
\def\Z{\mathbb{Z}}
\graphicspath{ {eps/} }

\newtheorem{Def}{Определение}
\newtheorem{Definition}[Def]{Определение}
\setcounter{Def}{0}%

\textheight=24cm  % высота текста
\textwidth=16cm % ширина текста
\oddsidemargin=0pt % отступ от левого края
\topmargin=-1.5cm % отступ от верхнего края
\parindent=24pt % абзацный отступ
\parskip=0pt % интервал между абзацами
\tolerance=2000 % "терпимость" к жидким строкам
\flushbottom % выравнивание высоты страниц
%\graphicspath{{data/}}
%\graphicspath{{data/further_research/final_pic/}}
\renewcommand{\baselinestretch}{1.3}
\fontsize{13}{15.6}\selectfont

%\bibliographystyle{unsrt}
\linespread{1.5}
\def\bblsep{Sep}
\def\bbloct{Oct}
\def\bblmar{Mar}

%%Листинг:
\usepackage{xcolor}
\usepackage{color} %% это для отображения цвета в коде
\usepackage{listings} %% собственно, это и есть пакет listings
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}} %% это сделает текст заголовка белым
%% код ниже нарисует серую рамочку вокруг заголовка кода.
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}


\begin{document}

\begin{center}
\begin{Large}
25.12.16. Занятие 5. \\ Вещественный бин.поиск. Бин.поиск по ответу.\\
\end{Large}
Подготовил \href{https://vk.com/ivansol42}{Соломатин Иван Андреевич}. \\
ivan.solomatin@phystech.edu; solomatin@informatics.ru
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Разбор}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{С.Суперсумма}

Разберём простой (и неправильный) вариант решения задачи. Он не оптимален в смысле вычислительной сложности, однако при данных ограничениях и тестах доходит до 11 теста, а дальше получает TL.
%Листинг:
\lstset{ %
language=C++,                 % выбор языка для подсветки (здесь это С++)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\small,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=10pt,                % как далеко отстоят номера строк от подсвечиваемого кода
backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)},   % если нужно добавить комментарии в коде
basicstyle=\small\ttfamily,
keywordstyle=\bfseries\color{green!40!black},
commentstyle=\itshape\color{purple!40!black},
identifierstyle=\color{blue},
stringstyle=\color{orange},
}
\renewcommand{\lstlistingname}{Решение}

\begin{lstlisting}[label=some-code,caption={Простое, но долгое}]
#include <iostream>
#include <algorithm>

using namespace std;

typedef struct elt
{
    int val;
    int num;
} elt;

int bin_search_r(int x, int l, int r, elt *a)
{
    while(r - l > 1)
    {
        int m = (l + r) / 2;
        if (a[m].val <= x)
			l = m;
        else
			r = m;
    }
    return l;
}

bool operator<(const elt &left, const elt &right)
{
	return left.val < right.val;
}

int main()
{
    //Считываем данные и складываем в структуры
    int n;
    int *res;
    cin >> n;
    elt *arr = new elt [n];
    res = new int [n];
    for (int i = 0; i < n; i++)
    {
        cin >> arr[i].val;
        arr[i].num = i;
        res[i] = 0;
    }
	
    //Сортируем
    sort(arr, arr + n);
	
    //Перебираем пару значений
    for (int i = 0; i < n; i++)
        for (int j = i + 1; j < n; j++)
		{
            //Проверяем, есть ли в массиве сумма двух выбранных значений
            int sum = arr[i].val + arr[j].val;
            int l = bin_search_r(sum, 0, n, arr);
            //Увеличиваем ответ для всех значений, равных sum
            while (arr[l].val == sum)
            {
                res[arr[l--].num]++;
            }
		}
		
    //Выводим ответ
    for (int i = 0; i < n; i++)
    {
        cout << res[i] << " ";
    }
	
    return 0;
}
\end{lstlisting}

Вот более быстрое и правильное решение:
\begin{lstlisting}[label=some-code,caption={Более сложное, но быстрое}]
#include <iostream>
#include <algorithm>
using namespace std;

struct elt
{
	int val;
	int num;
	int ans;
};

int n, N;
elt a[100000];
int vals[100000], vals2[100000];

elt make_elt(int val, int num)
{
	elt res;
	res.val = val;
	res.num = num;
	res.ans = 0;
	return res;
}

int bin_search(int x)
{
	int l = 0;
	int r = n;
	while (r - l > 1)
	{
		int m = (r + l) / 2;
		if (a[m].val <= x)
			l = m;
		else
			r = m;
	}
	return l;
}

int main()
{
	cin >> N;
	//Читаем массив и сохраняем копию
	for (int i = 0; i < N; i++)
	{
		cin >> vals[i];
		vals2[i] = vals[i];
	}
	
	//Сортируем одну из копий массива
	sort(vals, vals + N);

	//Записываем структуры (значение, количество).
	int cur_num = 0;
	n = 0;
	for (int i = 1; i <= N; i++)
		if ((i == N) || (vals[i - 1] != vals[i]))
		{
			a[n++] = make_elt(vals[i - 1], cur_num + 1);
			cur_num = 0;
		}
		else
			cur_num++;

	//Перебираем одно значение
	for (int i = 0; i < n; i++)
	{
		//Пытаемся составить сумму из двух одинаковых чисел a[i].val.
		int l = bin_search(2 * a[i].val);
		if (a[l].val == 2 * a[i].val)
			a[l].ans += a[i].num * (a[i].num - 1) / 2;

		//Перебираем второе значение
		for (int j = i + 1; j < n; j++)
		{
			//Составляем сумму из a[i].val и a[j].val
			int l = bin_search(a[i].val + a[j].val);
			if (a[l].val == a[i].val + a[j].val)
				a[l].ans += a[i].num * a[j].num;
		}
	}

	//Для вывода берём копию изначального массива и ищем
	//для каждого значения ответ в массиве структур.
	for (int i = 0; i < N; i++)
		cout << a[bin_search(vals2[i])].ans << ' ';
	cout << endl;
	return 0;
}
\end{lstlisting}

\paragraph{Сложность решения 1}
Оценим вычислительную сложность.
\begin{enumerate}
\item Сортируем массив. Это $O(N\log _2 N)$.
\item Мы перебираем два элемента из массива (i и j). Это $O(N^2)$. Суммарно $O(N\log _2 N + N^2)$.
\item Внутри цикла для каждых двух элементов i и j мы находим с помощью бин.поиска самый правый элемент, равный сумме a[i] + a[j]. Это $O(N^2 \log _2 N)$. Получаем $O(N\log _2 N + N^2 \log _2 N)$
\item Внутри того же цикла для каждых двух элементов i и j мы увеличиваем ответ для всех элементов массива, равных сумме a[i] + a[j]. Таких элементов, вообще говоря, может быть порядка $N$. То есть, эта операция имеет сложность $O(N^2 * N) = O(N^3)$. Поэтому, в итоге получаем сложность $O(N\log _2 N + N^2 \log _2 N + N^3) = O(N^3)$.
\end{enumerate}
При $N = 5000$ и сложности $O(N^3)$ время работы можно оценить как $t = \cfrac{5000^3}{10^9} = 125$ секунд. Это слишком долго. Таких тестов изначально не было в задаче "Суперсумма", однако, в задаче Суперсумма2.Возвращение такое решение уже не проходит. Для неё нужно придумать решение со сложностью $O(N^2 \log N)$.

\paragraph{Сложность решения 2}
\begin{enumerate}
\item Сортируем массив. Это $O(N\log _2 N)$.
\item \glqqСклеиваем\grqq $\;$ одинаковые значения. Это $O(N)$. Суммарно $O(N\log _2 N + N)$.
\item Перебираем два элемента из массива (i и j). Это $O(N^2)$. Суммарно $O(N\log _2 N + N + N^2)$.
\item Внутри цикла для каждых двух элементов i и j мы находим с помощью бин.поиска самый правый элемент, равный сумме a[i] + a[j] и увеличиваем соответствующий этому значению ответ. Итого, получаем сложность $O(N\log _2 N + N + N^2\log _2 N) = O(N^2\log _2 N)$
\end{enumerate}
При $N = 5000$ и сложности $O(N^2\log _2 N)$ время работы можно оценить как $t = \cfrac{5000^2 \log _2 5000}{10^9} = \cfrac{25000000 * 12}{10^9} = 0.3$ секунды. Гораздо лучше.

На данной таблице приведены времена работы решения 1 и решения 2 на некоторых тестах:
\noindent
\begin{table}[H]
\begin{center}
\begin{tabular}{|l|p{3cm}|p{3cm}|}
\hline
Тест & Время работы решения 1 (с) & Время работы решения 2 (с)\\
\hline
$n = 3$ 									& 0.000 		& 0.000\\
$n = 100$ 									& 0.000 		& 0.000\\
$n = 1000$									& 0.023 		& 0.027\\
$n \approx 3500$ (почти все числа различны)	& 0.320 		& 0.363\\
$n = 5000$									& 0.513 		& 0.007\\
$n = 5000$ 									& 0.567 		& 0.003\\
$n = 5000$ (всего 3 различных значения)  	& $\sim$18.5	& 0.003\\
\hline
\end{tabular}
\end{center}
\end{table}
Из таблицы видно, что на больших тестах решение 2 работает быстрее.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Вещественный двоичный поиск}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Вещественные числа}
Во время работы с вещественными числами стоит учитывать, что вычисления производятся с некоторой машинной точностью. Это может привести к проблемам при сравнении, поэтому обычно сравнение вещественных чисел производят с некоторой наперёд заданной точностью (epsilon). Например, мы хотим сравнивать числа с точностью до 6 знака после запятой, тогда $eps = 0.000001$:
\begin{table}[H]
\caption{Сравнение вещественных чисел}
\label{table_rational_comparison}
\begin{center}
\begin{tabular}{|c|c|}
\hline
Сравнение целых чисел & Аналог для вещественных чисел\\
\hline
$x == y$ & $abs(x - y) < eps$\\
$x <= y$ & $x - y < eps$\\
$x >= y$ & $x - y > -eps$\\
$x < y$ & $x - y < -eps$\\
$x > y$ & $x - y > eps$\\
\hline
\end{tabular}
\end{center}
\end{table}

\paragraph{От массивов - к функциям}
Вспомним обычный двоичный поиск с прошлого занятия. Там мы в отсортированном по неубыванию массиве $a$ искали максимальное $i$ такое что $a[i] \geq x$ (правый бин.поиск) или минимальное $i$ такое что $a[i] \leq x$ (левый бин.поиск). \\
Теперь попробуем обобщить процедуру двоичного поиска на функцию одного вещественного аргумента. Допустим, у нас есть функция $f(x): \R \to \R$. Эта запись значит, что функция f принимает в качестве аргумента вещественное число $x \in \R$, и в качестве результата возвращает так же вещественное число $f(x) \in \R$. Итак, имеется функция $f(x)$ и мы хотим научиться находить такой $x_0$, что $f(x_0) = y$, то есть, другими словами, находить корень уравнения $f(x) = y$.\\
Вспомним про требование к приминению бин.поиска: массив должен быть отсортирован (например, по неубыванию). Запишем это требование (запись $\forall i$ значит \textit{для любого} $i$):
$$\forall i: a[i] \leq a[i+1]$$
Эквивалентное утверждение:
$$\forall i, j: i < j: a[i] \leq a[j]$$
(Читается как "\textit{Для всех $i$ и $j$, таких что $i < j$, выполняется условие $a[i] \leq a[j]$}")\\
Запишем аналогичное требование для функции:
$$\forall x_1, x_2: x_1 < x_2: f(x_1) \leq f(x_1)$$
Это свойство функции называется \textbf{монотонность}.\\
Таким образом, вещественный бин.поиск можно применять только к функции, которая \textbf{монотонна на исследуемом отрезке}.
Сама процедура вещественного двоичного поиска отличается от двоичного поиска по массиву двумя вещами:
\begin{enumerate}
\item Условием останова.
\item Сравнением значений.
\end{enumerate}
Условием останова является тот факт, что мы уже локализовали (нашли) искомое значение. Так как все вычисления мы проводим с точностью $eps$, то условие останова будет выглядеть как $r - l < eps$.\\
Сравнение значений производится в соответствии с таблицей \ref{table_rational_comparison} (стр. \pageref{table_rational_comparison}) тогда, когда это не влечёт потери точности (об этом будет сказано после примера).\\
\paragraph{Квадратный корень числа}
Рассмотрим процедуру двоичного поиска на примере поиска квадратного корня числа.\\
На вход подаётся число $y$, нужно найти $\sqrt{y}$ с точностью до 6 знака после запятой.\\

Заметим, что поиск корня числа это фактически поиск решения уравнения $x^2 = y$, то есть поиск такого числа $x_0: x_0^2 = y$. Это намекает на использование вещественного двоичного поиска. Заметим так же, что функция, по которой мы собираемся проводить двоичный поиск ($x^2$) монотонна на полуинтервале $[0; \infty)$. Таким образом, мы имеем полное право применить вещественный двоичный поиск к данной задаче.\\
В качестве правой границы отрезка мы можем использовать либо очень большое число (например, 1e100), либо, что оптимальней, некоторую оценку правой границы. В качестве такой оценки, например, можно использовать $max(y, 1)$.
\begin{lstlisting}[label=some-code,caption={Квадратный корень}]
#include <iostream>
#include <iomanip>
using namespace std;

typedef long double ld;
const ld eps = 1e-6;

ld sqrt(ld y)
{
    ld l = 0;
    ld r = max(y, ld(1.0));
    while (r - l > eps)
    {
        ld m = (l + r) / 2;
        if (m * m < y)
            l = m;
        else
            r = m;
    }
    return l;
}

int main()
{
    ld y;
    cin >> y;
    cout << fixed << setprecision(18) << sqrt(y) << endl;
    return 0;
}
\end{lstlisting}

Заметим, что в строке 15 сравнение вещественных чисел производется без eps. Почему так? Допустим, мы будем сравнивать числа $m*m$ и $y$ с точностью eps. Но $у = \sqrt{x}$, поэтому точность для $x$ уже будет составлять $\sqrt(eps)$. При $eps = 10^{-6}$, то всего $10^{-3}$, что не очень хорошо и может привести к WA.
\paragraph{Правый и левый бин.поиск}
Вещественный бин.поиск так же может быть правым и левым. Пусть, например, функция принимает значение $f(x) = y$ на отрезке $x \in [a; b]$. Тогда правый бин.поиск должен вернуть $b$, а левый $a$. Для того, чтобы понять, как написать правый или левый бин.поиск лучше всего нарисовать функцию и посмотреть, какие значения должны оказаться слева от l, а какие справа от r.
\section{Бинпоиск по ответу}
\paragraph{Формулировка через булеву функцию}
Мы научились применять бин.поиск к произвольной функции вещественной переменной. Однако, на область допустимых значений функции никаких ограничений не было. Допустим, мы хотим решить некоторую оптимиационную задачу. Например, найти максимальное $x$, удовлетворяющее условиям, которые заданы функцией b(x), принимающей значения 1 и 0. То есть найти $x_0 = \max x: b(x) = 1$. Это легко можно сделать с помощью двоичного поиска. Такой подход к решению задач называется бин.поиском по ответу.\\
Более подробно, подход состоит в следующем:
\begin{enumerate}
\item Для применения бин.поиска по ответу задача должна иметь вид "найти минимальное/максимальное значение, удовлетворяющее некоторым условиям".
\item Понять, какой вид имеют условия, которым должен удовлетворять ответ.
\item Определить отрезок на котором будет производиться поиск ответа.
\item Проверить, является ли функция, задающая условия монотонной на исследуемом отрезке, т.е. проверить, что она меняется с 1 на 0, или с 0 на 1 только один раз.
\item Реализовать двоичный поиск (на каждом шаге смотрим, удовлетворяет ли очередное m условиям, и смотрим, где будет лежать искомый ответ).
\end{enumerate}
\paragraph{Разбор очень простой задачи}
В качестве примера бин.поиска по ответу разберём "Очень простую задачу" (Задача B).\\
Для начала сделаем одну копию с помощью самого быстрого ксерокса, чтобы можно было пользоваться обоими ксероксами одновременно. Далее будем делать $N - 1$ копию, а к ответу прибавим $min(x, y)$. Далее будем действовать по пунктам, сформулированным выше:
\begin{enumerate}
\item В задаче нужно найти минимальное время, за которое можно сделать $N - 1$ копий.
\item Время t удовлетворяет условиям задачи, если за это время можно сделать хотя бы $N - 1$ копий, то есть, если $\left(\cfrac{t}{x} + \cfrac{t}{y} \geq n - 1\right)$.
\item Определяем отрезок. Минимальное допустимое время - 0. Максимальное оценим как max(x, y) * (N - 1).
\item Условия монотонны, т.к. если за время $t$ можно сделать $N$ копий, то и за время $t+1$ можно сделать $N$ копий.
\item Реализуем всё вышеперечисленное:
\end{enumerate}
\begin{lstlisting}[label=some-code,caption={Очень простая задача}]
#include <iostream>
using namespace std;

typedef long double ld;
const ld eps = 1e-8;
long long n, x, y;

//Булева функция, проверяющая, удовлетворяет ли время t необходимым условиям:
bool time_ok(long long t)
{
	return (t / x + t / y >= n - 1);
}

long long bin_search_by_answer()
{
	long long l = -1;
	long long r = max(x, y) * (n - 1);
	while (r - l > 1)
	{
		long long m = (l + r) / 2;
		if (time_ok(m))
			r = m;
		else
			l = m;
	}
	return r;
}

int main()
{
	cin >> n >> x >> y;
	cout << min(x, y) + bin_search_by_answer();
	return 0;
}
\end{lstlisting}


\end{document}
